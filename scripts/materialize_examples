#!/usr/bin/env python3
"""Materialize example git repositories as local branches.

Scans Markdown files in ``content/examples/`` for shell code blocks that
carry both ``# pragma: testrun`` and ``# pragma: materialize`` annotations.
Each annotated script is executed in a temporary directory and the resulting
git repository sub-directories are imported as local branches under the
``examples/`` namespace.

Branch naming::

    examples/{file-stem}/{testrun-id}/{repo-subdir}

A SHA-256 hash of the script content is stored as a **git note**
(``refs/notes/materialize``) on the branch tip commit.  If the hash
matches, regeneration is skipped.

By default, branches are created locally for inspection.  Use ``--push``
to send them (and notes) to a remote.
"""
from __future__ import annotations

import argparse
import hashlib
import os
import re
import shutil
import stat
import subprocess
import sys
import tempfile
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent))
from snippet_parser import ScriptBlock, iter_script_blocks

# Fixed epoch for deterministic git commits inside the example scripts.
FIXED_EPOCH = "2000-01-01T00:00:00+00:00"

CONTENT_DIR = Path("content/examples")

# Custom notes ref to avoid colliding with default refs/notes/commits.
NOTES_REF = "refs/notes/materialize"


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def script_hash(code: str) -> str:
    """Return the SHA-256 hex digest of *code*."""
    return hashlib.sha256(code.encode("utf-8")).hexdigest()


def branch_name(file_stem: str, testrun_id: str, repo_subdir: str) -> str:
    """Compute the target branch name."""
    return f"examples/{file_stem}/{testrun_id}/{repo_subdir}"


def repo_toplevel() -> Path:
    """Return the absolute path of the current git working tree root."""
    result = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True,
        check=True,
    )
    return Path(result.stdout.strip())


def detect_remote_url(remote: str) -> str:
    """Detect the remote URL for submodule rewriting.

    In GitHub Actions ``GITHUB_REPOSITORY`` is always set.  Otherwise fall
    back to the configured remote URL.
    """
    gh_repo = os.environ.get("GITHUB_REPOSITORY")
    if gh_repo:
        return f"https://github.com/{gh_repo}"
    result = subprocess.run(
        ["git", "remote", "get-url", remote],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0:
        return result.stdout.strip()
    return ""


# ---------------------------------------------------------------------------
# Git notes for cache
# ---------------------------------------------------------------------------

def get_cached_hash(target_branch: str) -> str | None:
    """Read the script hash from the git note on *target_branch*'s tip.

    Returns ``None`` if the branch or note doesn't exist.
    """
    # Resolve branch tip commit
    tip = subprocess.run(
        ["git", "rev-parse", "--verify", f"refs/heads/{target_branch}"],
        capture_output=True,
        text=True,
    )
    if tip.returncode != 0:
        return None
    commit = tip.stdout.strip()

    # Read the note
    note = subprocess.run(
        ["git", "notes", f"--ref={NOTES_REF}", "show", commit],
        capture_output=True,
        text=True,
    )
    if note.returncode != 0:
        return None
    for line in note.stdout.splitlines():
        if line.startswith("Script-Hash:"):
            return line.split(":", 1)[1].strip()
    return None


def store_hash_note(target_branch: str, hash_val: str) -> None:
    """Attach a script-hash note to *target_branch*'s tip commit."""
    tip = subprocess.run(
        ["git", "rev-parse", f"refs/heads/{target_branch}"],
        capture_output=True,
        text=True,
        check=True,
    )
    commit = tip.stdout.strip()
    subprocess.run(
        [
            "git", "notes", f"--ref={NOTES_REF}",
            "add", "-f", "-m", f"Script-Hash: {hash_val}",
            commit,
        ],
        check=True,
    )


# ---------------------------------------------------------------------------
# Submodule URL rewriting
# ---------------------------------------------------------------------------

def rewrite_submodule_urls(
    repo_dir: Path,
    file_stem: str,
    testrun_id: str,
    remote_url: str,
) -> None:
    """Rewrite ``.gitmodules`` URLs from relative paths to remote branches.

    A relative URL like ``../raw-data.git`` is replaced with the HTTPS URL
    of the branch ``examples/{file_stem}/{testrun_id}/{subdir}`` in the
    same repository, where *subdir* is the bare-repo name without ``.git``.
    """
    gitmodules = repo_dir / ".gitmodules"
    if not gitmodules.exists():
        return

    text = gitmodules.read_text(encoding="utf-8")
    # Match lines like: url = ../raw-data.git
    url_re = re.compile(r"^(\s*url\s*=\s*)(\.\./[^\s]+\.git)\s*$", re.MULTILINE)

    def _replace(m: re.Match) -> str:
        prefix = m.group(1)
        rel_path = m.group(2)  # e.g. ../raw-data.git
        # Extract the subdir name: ../raw-data.git → raw-data
        subdir = rel_path.rsplit("/", 1)[-1]
        if subdir.endswith(".git"):
            subdir = subdir[:-4]
        # Convention: bare repo "foo.git" → working dir "foo-work"
        target = branch_name(file_stem, testrun_id, subdir + "-work")
        return f"{prefix}{remote_url}\n\tbranch = {target}"

    new_text = url_re.sub(_replace, text)
    if new_text != text:
        gitmodules.write_text(new_text, encoding="utf-8")
        subprocess.run(
            ["git", "-C", str(repo_dir), "add", ".gitmodules"],
            check=True,
        )
        subprocess.run(
            ["git", "-C", str(repo_dir), "commit", "--amend", "--no-edit"],
            check=True,
            env={
                **os.environ,
                "GIT_AUTHOR_DATE": FIXED_EPOCH,
                "GIT_COMMITTER_DATE": FIXED_EPOCH,
            },
        )


# ---------------------------------------------------------------------------
# Local branch creation
# ---------------------------------------------------------------------------

def import_as_local_branch(repo_dir: Path, target_branch: str) -> None:
    """Fetch *repo_dir*'s HEAD into a local branch in the current repo."""
    toplevel = repo_toplevel()
    subprocess.run(
        [
            "git", "fetch",
            str(repo_dir),
            f"+HEAD:refs/heads/{target_branch}",
        ],
        check=True,
        cwd=str(toplevel),
    )
    print(f"  branch → {target_branch}")


def create_worktree(
    repo_dir: Path,
    target_branch: str,
    worktrees_under: Path,
) -> None:
    """Copy the repo content into a directory for inspection."""
    dest = worktrees_under / target_branch
    if dest.exists():
        shutil.rmtree(dest)
    dest.parent.mkdir(parents=True, exist_ok=True)
    shutil.copytree(repo_dir, dest)
    print(f"  worktree → {dest}")


# ---------------------------------------------------------------------------
# Push
# ---------------------------------------------------------------------------

def push_branches_and_notes(remote: str) -> None:
    """Push all ``examples/*`` branches and materialize notes to *remote*."""
    # Gather local example branches
    result = subprocess.run(
        ["git", "branch", "--list", "examples/*", "--format=%(refname:short)"],
        capture_output=True,
        text=True,
    )
    branches = [b.strip() for b in result.stdout.splitlines() if b.strip()]
    if not branches:
        print("No example branches to push.")
        return

    # Build refspecs
    refspecs = [f"refs/heads/{b}:refs/heads/{b}" for b in branches]
    # Also push notes
    refspecs.append(f"{NOTES_REF}:{NOTES_REF}")

    print(f"Pushing {len(branches)} branch(es) + notes to {remote}…")
    subprocess.run(
        ["git", "push", "--force", remote] + refspecs,
        check=True,
    )
    print("Push complete.")


# ---------------------------------------------------------------------------
# Script execution
# ---------------------------------------------------------------------------

def execute_script(
    block: ScriptBlock,
    strict: bool,
) -> Path | None:
    """Run a script block in a temp dir and return the temp dir path.

    Returns ``None`` if execution was skipped (missing tools).
    """
    pragmas = block.pragmas
    requires = str(pragmas.get("requires", "sh")).split()
    missing = [t for t in requires if not shutil.which(t)]
    if missing:
        if strict:
            print(f"  ERROR: missing tools: {', '.join(missing)}", file=sys.stderr)
            sys.exit(1)
        print(f"  skip: missing {', '.join(missing)}")
        return None

    timeout = int(str(pragmas.get("timeout", "60")))
    testrun_id = str(pragmas.get("testrun", "unnamed"))

    tmpdir = Path(tempfile.mkdtemp(prefix=f"materialize-{testrun_id}-"))
    script_path = tmpdir / "run.sh"
    script_path.write_text(block.code, encoding="utf-8")
    script_path.chmod(script_path.stat().st_mode | stat.S_IEXEC)

    env = {
        **os.environ,
        "GIT_AUTHOR_DATE": FIXED_EPOCH,
        "GIT_COMMITTER_DATE": FIXED_EPOCH,
        # Point TMPDIR at our tmpdir so mktemp inside the script creates
        # subdirectories we can find afterwards.
        "TMPDIR": str(tmpdir),
    }

    try:
        subprocess.run(
            ["sh", str(script_path)],
            timeout=timeout,
            check=True,
            env=env,
        )
    except subprocess.TimeoutExpired:
        print(f"  ERROR: script timed out after {timeout}s", file=sys.stderr)
        shutil.rmtree(tmpdir, ignore_errors=True)
        return None
    except subprocess.CalledProcessError as exc:
        expected_rc = int(str(pragmas.get("exitcode", "0")))
        if exc.returncode != expected_rc:
            print(
                f"  ERROR: script exited {exc.returncode} (expected {expected_rc})",
                file=sys.stderr,
            )
            shutil.rmtree(tmpdir, ignore_errors=True)
            return None
        # Non-zero exit is expected — continue.

    return tmpdir


def find_repo_subdir(tmpdir: Path, subdir_name: str) -> Path | None:
    """Locate a git repository subdirectory in *tmpdir* (recursive search)."""
    for candidate in tmpdir.rglob(subdir_name):
        if candidate.is_dir():
            git_dir = candidate / ".git"
            if git_dir.exists():
                return candidate
    return None


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def process_block(
    block: ScriptBlock,
    *,
    remote_url: str,
    dry_run: bool,
    strict: bool,
    worktrees_under: Path | None,
) -> None:
    """Process a single script block: execute, capture, import as branch."""
    testrun_id = str(block.pragmas.get("testrun", "unnamed"))
    materialize_list = block.pragmas.get("materialize", [])
    if not isinstance(materialize_list, list):
        materialize_list = [materialize_list]

    if not materialize_list:
        return

    print(f"\n[{block.file_stem}/{testrun_id}]")
    hash_val = script_hash(block.code)

    # Check cache for all targets — skip if all match
    if not worktrees_under:
        all_cached = True
        for repo_subdir in materialize_list:
            bname = branch_name(block.file_stem, testrun_id, repo_subdir)
            existing = get_cached_hash(bname)
            if existing != hash_val:
                all_cached = False
                break
        if all_cached:
            print(f"  cache hit (hash {hash_val[:12]}…) — skipping")
            return

    print(f"  hash {hash_val[:12]}… — executing script")
    tmpdir = execute_script(block, strict=strict)
    if tmpdir is None:
        return

    try:
        for repo_subdir in materialize_list:
            bname = branch_name(block.file_stem, testrun_id, repo_subdir)
            repo_dir = find_repo_subdir(tmpdir, repo_subdir)
            if repo_dir is None:
                print(f"  WARNING: {repo_subdir} not found in {tmpdir}")
                continue

            # Verify it's a valid git repo
            check = subprocess.run(
                ["git", "-C", str(repo_dir), "rev-parse", "--git-dir"],
                capture_output=True,
            )
            if check.returncode != 0:
                print(f"  WARNING: {repo_subdir} is not a git repo")
                continue

            # Rewrite submodule URLs
            if remote_url:
                rewrite_submodule_urls(
                    repo_dir, block.file_stem, testrun_id, remote_url,
                )

            if dry_run:
                print(f"  dry-run: would create branch {bname}")
            elif worktrees_under:
                create_worktree(repo_dir, bname, worktrees_under)
            else:
                import_as_local_branch(repo_dir, bname)
                store_hash_note(bname, hash_val)
    finally:
        shutil.rmtree(tmpdir, ignore_errors=True)


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(
        description="Materialize example git repos as local branches.",
    )
    parser.add_argument(
        "--strict",
        action="store_true",
        help="Fail on missing tools instead of skipping.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Parse and execute but don't create branches.",
    )
    parser.add_argument(
        "-r",
        "--remote",
        default="origin",
        help="Git remote name (default: origin).",
    )
    parser.add_argument(
        "--push",
        action="store_true",
        help="Push example branches and notes to remote after materializing.",
    )
    parser.add_argument(
        "--worktrees-under",
        type=Path,
        default=None,
        metavar="PATH",
        help="Create directory copies instead of local branches.",
    )
    args = parser.parse_args(argv)

    if not CONTENT_DIR.is_dir():
        print(f"ERROR: {CONTENT_DIR} not found", file=sys.stderr)
        sys.exit(1)

    # Detect remote URL for submodule rewriting (even in local-only mode,
    # we rewrite submodule URLs to point at the eventual remote location).
    remote_url = detect_remote_url(args.remote)
    if remote_url:
        print(f"Remote URL (for submodule rewriting): {remote_url}")

    md_files = sorted(CONTENT_DIR.glob("*.md"))
    if not md_files:
        print("No markdown files found.")
        return

    for md_path in md_files:
        for block in iter_script_blocks(md_path):
            materialize_list = block.pragmas.get("materialize", [])
            if not materialize_list:
                continue
            process_block(
                block,
                remote_url=remote_url,
                dry_run=args.dry_run,
                strict=args.strict,
                worktrees_under=args.worktrees_under,
            )

    if args.push and not args.dry_run:
        push_branches_and_notes(args.remote)

    print("\nDone.")


if __name__ == "__main__":
    main()
